/*
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/* eslint-disable no-param-reassign */
import { toString } from 'mdast-util-to-string';
import one from './one.js';
import handlers from './handlers/index.js';
import IDSlugger from './id-slugger.js';

/**
 * @typedef {Node} List
 *
 * Stack of List entries (i.e. the <LI>s), where the last is the tail of the list
 * @typedef {List[]} ListStack
 *
 * The containers for a list stack. eg the table-cell or just the document.
 * This is to track the lists within the individual parents.
 *
 * Currently, we only create a new list container for the table-cell.
 *
 * Note: that the stack is reversed, i.e. the first is the deepest one.
 * @typedef {ListStack[]} ListContainers
 *
 * @typedef Bookmark
 * @property {string} name
 * @property {Node} target
 * @property {Node[]} links
 *
 * Converts the docx AST to markdown ast.
 * @param {object} tree the docx ast
 * @param {object} opts options
 * @param {boolean} [opts.gridtables = false] generate gridtables
 * @return {object} the markdown ast
 */
export default async function dast2mdast(tree, opts = {}) {
  const byId = {};

  const h = (type, props, children) => {
    if (
      !children
      && (typeof props === 'string'
      || (typeof props === 'object' && 'length' in props))
    ) {
      children = props;
      props = {};
    }
    const result = { type, ...props };

    if (typeof children === 'string') {
      result.value = children;
    } else if (children) {
      result.children = children;
    }
    return result;
  };

  h.nodeById = byId;
  h.baseFound = false;
  h.frozenBaseUrl = null;
  h.handlers = handlers;
  h.numbering = {};
  h.gridtables = opts.gridtables;
  h.bookmarks = {};

  /** @type {ListContainers} */
  h.listContainers = [[]];

  /**
   * @param {string} name
   * @returns {Bookmark}
   */
  h.getBookmark = (name) => {
    let bm = h.bookmarks[name];
    if (!bm) {
      bm = {
        name,
        target: null,
        links: [],
      };
      h.bookmarks[name] = bm;
    }
    return bm;
  };

  const mdast = one(h, tree, null);

  // process bookmarks. note that we _should_ re-slug them after the headings are sanitized in
  // mdast2md. another option would be to keep the `bookmark` nodes in the mdast and only
  // process them in mdast2md. but then, the dast2mdast would produce non standard mdast.
  const bookmarks = Object.values(h.bookmarks);
  if (!bookmarks.length) {
    return mdast;
  }

  const slugger = new IDSlugger();
  for (const bm of bookmarks) {
    if (!bm.target) {
      if (bm.name !== '_top') {
        // eslint-disable-next-line no-continue
        continue;
      }
      bm.id = '';
    } else if (bm.target.type === 'heading') {
      // if heading, create an ID from its text
      if (!bm.target.id) {
        const text = toString(bm.target).trim();
        bm.target.id = slugger.slug(text || 'heading');
      }
      bm.id = bm.target.id;
    } else if (bm.links.length) {
      // create an anchor node for non-heading bookmarks
      bm.id = slugger.slug('bookmark');
      bm.target.type = 'html';
      bm.target.value = `<a id="${bm.id}"></a>`;
    } else {
      // remove bookmark node if no link is pointing to it
      bm.target.type = 'text';
      bm.target.value = '';
    }
    // adjust all links uris to the id
    for (const link of bm.links) {
      link.url = `#${bm.id}`;
    }
  }
  return mdast;
}
