/*
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
import { toString } from 'mdast-util-to-string';
import all from '../all.js';

/**
 * Some Monospace fonts
 */
const CODE_FONTS = {
  'Courier New': true,
  'Source Code Pro': true,
  VT323: true,
  Consolas: true,
  Courier: true,
  'Nanum Gothic Coding': true,
  Cousine: true,
};

/**
 * Checks if the font specified by the text style is a font used to format code.
 * @param {string} fontFamily
 * @returns {boolean} {@code true} if the font is a code font.
 */
function isCodeFont(fontFamily) {
  if (!fontFamily) {
    return false;
  }
  return (fontFamily in CODE_FONTS || fontFamily.match(/\sMono/));
}

function isInlineCode(node) {
  return node.styleId === 'InlineCode' || isCodeFont(node.font);
}

export default function run(h, node, parent, siblings) {
  const { children } = node;
  const nodes = all(h, node);

  if (children && children.length !== 0 && nodes.length === 0) {
    return undefined;
  }

  if (isInlineCode(node)) {
    const text = toString({ children: nodes });
    const lines = text.split(/(\n)/);
    const prev = siblings.length > 0 ? siblings[siblings.length - 1] : {};
    while (lines.length > 0 && lines[0] !== '\n' && prev.type === 'inlineCode') {
      prev.value += lines.shift();
    }
    return lines
      .filter((value) => !!value)
      .map((value) => ({ type: value === '\n' ? 'break' : 'inlineCode', value }));
  }

  let result = nodes;
  if (node.verticalAlignment === 'superscript') {
    result = [h('superscript', result)];
  }
  if (node.verticalAlignment === 'subscript') {
    result = [h('subscript', result)];
  }
  if (node.isUnderline && node.styleId !== 'Hyperlink') {
    result = [h('underline', result)];
  }
  if (node.isBold) {
    result = [h('strong', result)];
  }
  if (node.isItalic) {
    result = [h('emphasis', result)];
  }
  if (node.isStrikethrough) {
    result = [h('delete', result)];
  }

  return result;
}
