/*
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
import { toString } from 'mdast-util-to-string';
import all from '../all.js';

const HEADING_MAP = {
  Heading1: 1,
  Heading1Char: 1,
  Heading2: 2,
  Heading2Char: 2,
  Heading3: 3,
  Heading3Char: 3,
  Heading4: 4,
  Heading4Char: 4,
  Heading5: 5,
  Heading5Char: 5,
  Heading6: 6,
  Heading6Char: 6,
  Heading7: 7,
  Heading7Char: 7,
  Heading8: 8,
  Heading8Char: 8,
  'heading 1': 1,
  'heading 2': 2,
  'heading 3': 3,
  'heading 4': 4,
  'heading 5': 5,
  'heading 6': 6,
  'heading 7': 7,
  'heading 8': 8,
};

function isHorizontalLine(nodes) {
  const value = toString(nodes).trim();
  return (value === '---' || value === '\u2014');
}

function getHeadingDepth(node) {
  const { styleId, styleName } = node;
  if (styleId in HEADING_MAP) {
    return HEADING_MAP[styleId];
  }
  if (styleName in HEADING_MAP) {
    return HEADING_MAP[styleName];
  }
  return 0;
}

function isListParagraph(node) {
  const { styleId, styleName, numbering } = node;
  return styleId === 'ListParagraph'
    || (styleName && styleName.toLowerCase() === 'list paragraph')
    || (numbering && 'numId' in numbering);
}

function isCodeBlock(node) {
  const { styleId, styleName } = node;
  if (styleId === 'CodeBlock') {
    return true;
  }
  return styleName && styleName.toLowerCase() === 'code block';
}

function isBlockquote(node) {
  const { styleId, styleName } = node;
  if (styleId === 'Quote') {
    return true;
  }
  return styleName && styleName.toLowerCase() === 'quote';
}

function findFrom(nodes, start, pred) {
  let idx = start;
  while (idx < nodes.length) {
    if (pred(nodes[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

function handleBorder(border, ret) {
  if (border?.type === 'single' && border.size === '6' && border.space === '1') {
    ret.push({ type: 'thematicBreak' });
  }
}

/**
 * For each paragraph, check if there is an (inlinecode br+ inlincode) sequence and promote them
 * to codeblocks at the container level.
 * @param ret
 */
function collapseInlineCode(ret, prev) {
  for (let p = 0; p < ret.length; p += 1) {
    const { type, children } = ret[p];
    if (type === 'paragraph') {
      for (let i = 0; i < children.length; i += 1) {
        const next = findFrom(children, i, (n) => n.type === 'inlineCode');
        if (next < 0) {
          break;
        }
        // there should be at least 3 nodes remaining, otherwise we keep the inline code
        if (children.length - next < 3) {
          break;
        }
        // if previous node is a break, this is might be the start of a code block
        if (next === 0 || children[next - 1].type === 'break') {
          // find first non codeish
          const last = findFrom(children, next + 1, (n) => n.type !== 'inlineCode' && n.type !== 'break');
          if (last < 0 || children[last - 1].type === 'break') {
            // detected a codeblock... split the paragraph
            if (next > 0) {
              // move first chunk to new paragraph
              const kids = children.splice(0, next);
              while (kids[kids.length - 1]?.type === 'break') {
                kids.pop();
              }
              ret.splice(p, 0, {
                type: 'paragraph',
                children: kids,
              });
              p += 1;
            }
            if (last < 0) {
              // entire paragraph is code block
              ret.splice(p, 1, {
                type: 'code',
                value: toString(ret[p]).trimEnd(),
              });
              break;
            }
            // create code block
            const codeblock = last < 0 ? children : children.splice(0, last - next);
            ret.splice(p, 0, {
              type: 'code',
              value: toString({ children: codeblock }).trimEnd(),
            });
            p += 1;
            i = -1;
          } else {
            // look for more
            i = last;
          }
        } else {
          // otherwise look for more
          i = next;
        }
      }

      // merge with previous if needed
      if (children.length && children.findIndex((n) => n.type !== 'inlineCode' && n.type !== 'break') < 0) {
        // eslint-disable-next-line no-param-reassign
        ret[p].singleLineCode = true;
        if (p === 0 && prev.singleLineCode) {
          if (prev.type === 'paragraph') {
            // eslint-disable-next-line no-param-reassign
            prev.type = 'code';
            // eslint-disable-next-line no-param-reassign
            prev.value = `${toString(prev)}\n${toString(ret[p])}`;
            // eslint-disable-next-line no-param-reassign
            delete prev.children;
          } else {
            // eslint-disable-next-line no-param-reassign
            prev.value += `\n${toString(ret[p])}`;
          }
          ret.splice(p, 1);
          p -= 1;
        }
      }
    }
  }
}

export default function paragraph(h, node, parent, siblings) {
  const { children } = node;
  const nodes = all(h, node);
  if (children && children.length !== 0 && nodes.length === 0) {
    return undefined;
  }

  const ret = [];
  handleBorder(node.border?.top, ret);

  // check for list
  const [lists] = h.listContainers;
  if (isListParagraph(node)) {
    const numbering = node.numbering || {};
    const { numId = 0, isOrdered = false, level = '0' } = numbering;
    const lvl = Number.parseInt(level, 10);
    const listProps = {
      ordered: isOrdered,
      spread: false,
      level: lvl,
    };
    // find correct parent
    let tail;
    while (lists.length > 0) {
      tail = lists.pop();
      if (tail.ordered !== isOrdered && tail.level === lvl) {
        tail = null;
      } else if (lists.length <= lvl) {
        break;
      }
      tail = null;
    }
    if (!tail) {
      tail = h('list', listProps, []);
      ret.push(tail);
    }
    lists.push(tail);
    while (lists.length <= lvl) {
      const newList = h('list', listProps, []);
      if (tail.children.length > 0) {
        // append new list to end of the last list item
        tail.children[tail.children.length - 1].children.push(newList);
      } else {
        tail.children.push({
          type: 'listItem',
          spread: false,
          children: [newList],
        });
      }
      tail = newList;
      lists.push(tail);
    }
    const listItem = {
      type: 'listItem',
      spread: false,
      children: [h('paragraph', {}, nodes)],
    };

    // track numbering per id and level
    if (isOrdered) {
      let numInfo = h.numbering[numId];
      if (!numInfo) {
        numInfo = {
          levels: [],
        };
        // eslint-disable-next-line no-param-reassign
        h.numbering[numId] = numInfo;
      }
      while (numInfo.levels.length <= lvl) {
        numInfo.levels.push({ num: 1 });
      }
      // clear levels after current, as sub-lists always restart the numbering
      numInfo.levels.splice(lvl + 1);
      const lvlInfo = numInfo.levels[lvl];
      listItem.bullet = `${lvlInfo.num}.`;
      lvlInfo.num += 1;
    }
    tail.children.push(listItem);
    return ret;
  }
  // clear lists list marker
  // eslint-disable-next-line no-param-reassign
  h.listContainers[0] = [];

  // check for heading
  let depth = getHeadingDepth(node);
  if (!depth) {
    // if any of the child nodes is a heading (or heading char),
    // turn the entire paragraph into a heading
    const childHeading = children.find(getHeadingDepth);
    if (childHeading) {
      depth = getHeadingDepth(childHeading);
    }
  }

  if (depth) {
    // check if no horizontal line in heading
    if (isHorizontalLine(nodes)) {
      ret.push(h('thematicBreak'));
    } else {
      const heading = h('heading', { depth }, nodes);
      // check bookmark children (could have multiple)
      for (let idx = 0; idx < nodes.length; idx += 1) {
        const child = nodes[idx];
        if (child.type === 'bookmark') {
          // set the bookmark target to this heading and remove the child
          child.bookmark.target = heading;
          nodes.splice(idx, 1);
          idx -= 1;
        }
      }
      ret.push(heading);
    }
    handleBorder(node.border?.bottom, ret);
    return ret;
  }

  // check for codeblock
  const prev = siblings.length > 0 ? siblings[siblings.length - 1] : {};
  if (isCodeBlock(node)) {
    const text = toString({ children: nodes });
    // check if previous sibling was code block
    if (prev.type === 'code') {
      // eslint-disable-next-line no-param-reassign
      prev.value += `\n${text}`;
      return undefined;
    }
    ret.push(h('code', text));
    return ret;
  }

  // merge consecutive text blocks
  for (let i = 0; i < nodes.length - 1; i += 1) {
    const curr = nodes[i];
    const next = nodes[i + 1];
    if (curr.type === 'text' && next.type === 'text') {
      curr.value += next.value;
      nodes.splice(i + 1, 1);
      i -= 1;
    }
  }

  // check for thematicBreaks and frontmatter. they need to be block elements
  let prevBreak;
  let idx = nodes.findIndex(isHorizontalLine);
  while (idx >= 0) {
    const brk = h('thematicBreak');
    // remove the nodes up until the horizontal line
    const removed = nodes.splice(0, idx);
    // if last element is a break, ignore it.
    if (removed.length && removed[removed.length - 1].type === 'break') {
      brk.breakBefore = true;
      removed.pop();
    }

    // remove the horizontal line
    nodes.splice(0, 1);

    // also check if element following is a break
    if (nodes.length && nodes[0].type === 'break') {
      brk.breakAfter = true;
      nodes.splice(0, 1);
    }

    // if we had a previous thematic break, and all the text in between looks like yaml, then
    // create a frontmatter block
    if (prevBreak && prevBreak.breakAfter && brk.breakBefore) {
      const src = toString({ children: removed });
      prevBreak.type = 'yaml';
      prevBreak.value = src;
      prevBreak = null;
    } else {
      // else add the removed as a paragraph
      if (removed.length) {
        ret.push(h('paragraph', removed));
      }
      // and append the thematic break
      ret.push(brk);
      prevBreak = brk;
    }
    idx = nodes.findIndex(isHorizontalLine);
  }

  // handle remaining nodes
  if (nodes.length) {
    // avoid paragraphs with just a break
    if (nodes.length === 1 && nodes[0].type === 'break') {
      nodes.splice(0, 1);
    }
    ret.push(h('paragraph', nodes));
  }

  // for each paragraph, find groups of inline code that could form a code block
  collapseInlineCode(ret, prev);

  // check for block quote
  if (isBlockquote(node)) {
    return h('blockquote', ret);
  }
  handleBorder(node.border?.bottom, ret);
  return ret;
}
