/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/* eslint-disable no-param-reassign,no-console */
import stringify from 'remark-stringify';
import { unified } from 'unified';
import gfm from 'remark-gfm';

// import { inspect } from 'unist-util-inspect';
import {
  robustTables,
  suppressSpaceCode,
  sanitizeHeading,
  breaksAsSpaces,
  sanitizeFormats,
  sanitizeText,
  sanitizeTextAndFormats,
  sanitizeLinks,
  imageReferences, renderHtmlFormats,
} from '@adobe/helix-markdown-support';
import { remarkMatter } from '@adobe/helix-markdown-support/matter';
import remarkGridTable from '@adobe/remark-gridtables';

import processImages from './mdast-process-images.js';
import sanitizeAutoEmbeds from './mdast-sanitize-autoembeds.js';
import orderedListPlugin from './ordered-list/index.js';
import formatPlugin from './format-plugin/index.js';

/**
 * Converts the mdast to markdown using common filters suitable for helix.
 *
 * @param {Node} mdast The mdast
 * @param {Mdast2mdOptions} [opts] additional options
 * @returns {Promise<string>} the markdown representation.
 */
export default async function mdast2md(mdast, opts = {}) {
  const { listener, log = console } = opts;
  if (listener) {
    listener('beforePostProcess', mdast);
  }

  const processor = unified()
    .use(stringify, {
      strong: '*',
      emphasis: '_',
      bullet: '-',
      fence: '`',
      fences: true,
      incrementListMarker: true,
      rule: '-',
      ruleRepetition: 3,
      ruleSpaces: false,
    })
    .use(gfm)
    .use(formatPlugin)
    .use(remarkMatter)
    .use(orderedListPlugin);

  // process.stdout.write(inspect(mdast));
  // process.stdout.write('\n');

  if (opts.gridtables) {
    await sanitizeHeading(mdast);
    await sanitizeLinks(mdast);
    await sanitizeTextAndFormats(mdast);
    await suppressSpaceCode(mdast);
    await sanitizeAutoEmbeds(mdast);
    await processImages(log, mdast, opts.mediaHandler, opts.source);
    await imageReferences(mdast);
    processor.use(remarkGridTable);
  } else {
    await sanitizeHeading(mdast);
    await sanitizeFormats(mdast); // collapse formats once
    await sanitizeLinks(mdast);
    await sanitizeFormats(mdast); // and again for sanitized links
    await renderHtmlFormats(mdast);
    await sanitizeText(mdast);
    await suppressSpaceCode(mdast);
    await sanitizeAutoEmbeds(mdast);
    await processImages(log, mdast, opts.mediaHandler, opts.source);
    await robustTables(mdast);
    processor.use(breaksAsSpaces);
  }

  // process.stdout.write(inspect(mdast));
  // process.stdout.write('\n');

  if (listener) {
    listener('afterPostProcess', mdast);
    listener('beforeToMarkdown', mdast);
  }

  // noinspection JSVoidFunctionReturnValueUsed
  const md = processor.stringify(mdast);

  if (listener) {
    listener('afterToMarkdown', md);
  }

  return md;
}
