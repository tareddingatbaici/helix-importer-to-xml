/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
/* eslint-disable no-param-reassign */
import assert from 'assert';
import { visit } from 'unist-util-visit';
import processQueue from '@adobe/helix-shared-process-queue';

/**
 * @typedef ContentSource
 * @param {stream.Readable} stream The read stream
 * @param {number} size Size of the content
 */

/**
 * Gets the external azure or media resource for the given image buffer.
 *
 * @param {MediaHandler} [handler] The blob handler
 * @param {Buffer|ContentSource} data The buffer or content source of the image data
 * @param {string} contentType Content type of the data.
 * @param {string} source the source document
 * @returns {MediaResource} The blob
 */
async function getBlob(handler, data, contentType, source) {
  if (!data) {
    return null;
  }
  if (!handler) {
    assert(data instanceof Buffer, 'expected buffer to be a Buffer');
    return {
      uri: `data:${contentType};base64,${data.toString('base64')}`,
      contentType,
    };
  }

  const blob = data instanceof Buffer
    ? handler.createMediaResource(data, data.length, contentType, source)
    : await handler.createMediaResourceFromStream(data.stream, data.size, contentType, source);
  const exists = await handler.checkBlobExists(blob);
  if (!exists) {
    await handler.upload(blob);
  }
  return blob;
}

/**
 * Process images
 * - upload to azure
 * - decode QR code
 *
 * @parma {Logger} log Logger
 * @param {object} tree
 * @param {MediaHandler} blobHandler
 * @param {string} source the source document
 */
export default async function processImages(log, tree, blobHandler, source) {
  // gather all image nodes
  const images = [];

  visit(tree, (node, index, parent) => {
    if (node.type === 'image') {
      if ((node.readAsBuffer && typeof node.readAsBuffer === 'function') || node.url) {
        images.push({
          node,
          index,
          parent,
        });
      }
    }
    return visit.CONTINUE;
  });

  // upload images
  await processQueue(images, async ({ node }) => {
    let blob;

    // process inlined images first
    if (node.readAsBuffer) {
      try {
        const data = await node.readAsBuffer();
        blob = await getBlob(blobHandler, data, node.contentType, source);
      } catch (e) {
        log.error('Error reading blob data:', e.message);
        node.url = 'about:error';
        return;
      }
    }

    if (blob) {
      node.url = blob.uri;
    }
  }, 8);
}
