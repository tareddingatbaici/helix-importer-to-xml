"use strict";
(globalThis["webpackChunk_adobe_helix_importer_ui"] = globalThis["webpackChunk_adobe_helix_importer_ui"] || []).push([["vendors-node_modules_spectrum-web-components_overlay_sp-overlay_dev_js-node_modules_spectrum--904e70"],{

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");



function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
    const coords = {
      x,
      y
    };
    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);
    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));
  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));
  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));
  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));
      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';
          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));
          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);
      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);
      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);
      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);
        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);
        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);
        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};




/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),
/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),
/* harmony export */   computePosition: () => (/* binding */ computePosition),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),
/* harmony export */   hide: () => (/* binding */ hide),
/* harmony export */   inline: () => (/* binding */ inline),
/* harmony export */   limitShift: () => (/* binding */ limitShift),
/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   platform: () => (/* binding */ platform),
/* harmony export */   shift: () => (/* binding */ shift),
/* harmony export */   size: () => (/* binding */ size)
/* harmony export */ });
/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs");
/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs");






function getCssDimensions(element) {
  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {
    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;
  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
function getVisualOffsets(element) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  if (includeScale) {
    if (offsetParent) {
      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);
    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;
    }
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({
    width,
    height,
    x,
    y
  });
}

const topLayerSelectors = [':popover-open', ':modal'];
function topLayer(floating) {
  let isTopLayer = false;
  let x = 0;
  let y = 0;
  function setIsTopLayer(selector) {
    try {
      isTopLayer = isTopLayer || floating.matches(selector);
    } catch (e) {}
  }
  topLayerSelectors.forEach(selector => {
    setIsTopLayer(selector);
  });
  if (isTopLayer) {
    const containingBlock = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(floating);
    if (containingBlock) {
      const rect = containingBlock.getBoundingClientRect();
      x = rect.x;
      y = rect.y;
    }
  }
  return [isTopLayer, x, y];
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);
  const [isTopLayer] = elements ? topLayer(elements.floating) : [false];
  if (offsetParent === documentElement || isTopLayer) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);
    }
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);
  const body = element.ownerDocument.body;
  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === 'rtl') {
    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));
  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);
  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {
    return false;
  }
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed';
  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)) {
    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);
    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);
    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy, floating) {
  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {
      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let x = rect.left + scroll.scrollLeft - offsets.x;
  let y = rect.top + scroll.scrollTop - offsets.y;
  const [isTopLayer, topLayerX, topLayerY] = topLayer(floating);
  if (isTopLayer) {
    x += topLayerX;
    y += topLayerY;
    if (isOffsetParentAnElement) {
      x += offsetParent.clientLeft;
      y += offsetParent.clientTop;
    }
  }
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function getTrueOffsetParent(element, polyfill) {
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);
  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {
    return window;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'html' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'body' && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static' && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {
    return window;
  }
  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy, data.floating),
    floating: {
      x: 0,
      y: 0,
      ...(await getDimensionsFn(data.floating))
    }
  };
};

function isRTL(element) {
  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);
    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));
    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));
    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip;

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow;

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline;

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),
/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),
/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),
/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),
/* harmony export */   getNodeName: () => (/* binding */ getNodeName),
/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),
/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),
/* harmony export */   getParentNode: () => (/* binding */ getParentNode),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),
/* harmony export */   isTableElement: () => (/* binding */ isTableElement),
/* harmony export */   isWebKit: () => (/* binding */ isWebKit)
/* harmony export */ });
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle(element);

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}




/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alignments: () => (/* binding */ alignments),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   createCoords: () => (/* binding */ createCoords),
/* harmony export */   evaluate: () => (/* binding */ evaluate),
/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   getAlignment: () => (/* binding */ getAlignment),
/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),
/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),
/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),
/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),
/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),
/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),
/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),
/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),
/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),
/* harmony export */   getSide: () => (/* binding */ getSide),
/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   placements: () => (/* binding */ placements),
/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sides: () => (/* binding */ sides)
/* harmony export */ });
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}




/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/sp-overlay.dev.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/sp-overlay.dev.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _spectrum_web_components_base_src_define_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base/src/define-element.js */ "./node_modules/@spectrum-web-components/base/src/define-element.dev.js");
/* harmony import */ var _src_Overlay_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Overlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/Overlay.dev.js");



(0,_spectrum_web_components_base_src_define_element_js__WEBPACK_IMPORTED_MODULE_0__.defineElement)("sp-overlay", _src_Overlay_dev_js__WEBPACK_IMPORTED_MODULE_1__.Overlay);
//# sourceMappingURL=sp-overlay.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractOverlay: () => (/* binding */ AbstractOverlay),
/* harmony export */   guaranteedAllTransitionend: () => (/* binding */ guaranteedAllTransitionend),
/* harmony export */   nextFrame: () => (/* binding */ nextFrame),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   overlayTimer: () => (/* binding */ overlayTimer)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/index.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @spectrum-web-components/shared/src/reparent-children.js */ "./node_modules/@spectrum-web-components/shared/src/reparent-children.dev.js");
/* harmony import */ var _overlay_timer_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay-timer.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js");




const overlayTimer = new _overlay_timer_dev_js__WEBPACK_IMPORTED_MODULE_2__.OverlayTimer();
const noop = () => {
  return;
};
const guaranteedAllTransitionend = (el, action, cb) => {
  const abortController = new AbortController();
  const runningTransitions = /* @__PURE__ */ new Map();
  const cleanup = () => {
    abortController.abort();
    cb();
  };
  let guarantee2;
  let guarantee3;
  const guarantee1 = requestAnimationFrame(() => {
    guarantee2 = requestAnimationFrame(() => {
      guarantee3 = requestAnimationFrame(() => {
        cleanup();
      });
    });
  });
  const handleTransitionend = (event) => {
    if (event.target !== el) {
      return;
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) - 1
    );
    if (!runningTransitions.get(event.propertyName)) {
      runningTransitions.delete(event.propertyName);
    }
    if (runningTransitions.size === 0) {
      cleanup();
    }
  };
  const handleTransitionrun = (event) => {
    if (event.target !== el) {
      return;
    }
    if (!runningTransitions.has(event.propertyName)) {
      runningTransitions.set(event.propertyName, 0);
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) + 1
    );
    cancelAnimationFrame(guarantee1);
    cancelAnimationFrame(guarantee2);
    cancelAnimationFrame(guarantee3);
  };
  el.addEventListener("transitionrun", handleTransitionrun, {
    signal: abortController.signal
  });
  el.addEventListener("transitionend", handleTransitionend, {
    signal: abortController.signal
  });
  el.addEventListener("transitioncancel", handleTransitionend, {
    signal: abortController.signal
  });
  action();
};
function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
class AbstractOverlay extends _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.SpectrumElement {
  constructor() {
    super(...arguments);
    this.dispose = noop;
    this.offset = 0;
    this.willPreventClose = false;
  }
  async applyFocus(_targetOpenState, _focusEl) {
    return;
  }
  /* c8 ignore next 6 */
  get delayed() {
    return false;
  }
  set delayed(_delayed) {
    return;
  }
  /* c8 ignore next 6 */
  get disabled() {
    return false;
  }
  set disabled(_disabled) {
    return;
  }
  get elementResolver() {
    return this._elementResolver;
  }
  set elementResolver(controller) {
    this._elementResolver = controller;
  }
  /* c8 ignore next 3 */
  async ensureOnDOM(_targetOpenState) {
    return;
  }
  /* c8 ignore next 5 */
  async makeTransition(_targetOpenState) {
    return null;
  }
  async manageDelay(_targetOpenState) {
    return;
  }
  /* c8 ignore next 3 */
  async manageDialogOpen() {
    return;
  }
  /* c8 ignore next 3 */
  async managePopoverOpen() {
    return;
  }
  /* c8 ignore next 3 */
  managePosition() {
    return;
  }
  /* c8 ignore next 6 */
  get open() {
    return false;
  }
  set open(_open) {
    return;
  }
  get placementController() {
    return this._placementController;
  }
  set placementController(controller) {
    this._placementController = controller;
  }
  requestSlottable() {
  }
  returnFocus() {
    return;
  }
  /* c8 ignore next 6 */
  get state() {
    return "closed";
  }
  set state(_state) {
    return;
  }
  /* c8 ignore next 3 */
  manuallyKeepOpen() {
    return;
  }
  static update() {
    const overlayUpdateEvent = new CustomEvent("sp-update-overlays", {
      bubbles: true,
      composed: true,
      cancelable: true
    });
    document.dispatchEvent(overlayUpdateEvent);
  }
  static async open(triggerOrContent, interactionOrOptions, content, optionsV1) {
    await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @spectrum-web-components/overlay/sp-overlay.js */ "./node_modules/@spectrum-web-components/overlay/sp-overlay.dev.js"));
    const v2 = arguments.length === 2;
    const overlayContent = content || triggerOrContent;
    const overlay = new this();
    let restored = false;
    overlay.dispose = () => {
      overlay.addEventListener("sp-closed", () => {
        if (!restored) {
          restoreContent();
          restored = true;
        }
        requestAnimationFrame(() => {
          overlay.remove();
        });
      });
      overlay.open = false;
      overlay.dispose = noop;
    };
    const restoreContent = (0,_spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_1__.reparentChildren)([overlayContent], overlay, {
      position: "beforeend",
      prepareCallback: (el) => {
        const slot = el.slot;
        el.removeAttribute("slot");
        return () => {
          el.slot = slot;
        };
      }
    });
    const v1 = !v2 && overlayContent && optionsV1;
    if (v1) {
      if (true) {
        window.__swc.warn(
          overlay,
          `You are interacting with an ${overlay.localName} element via a deprecated imperative API. This API will be removed in a future version of the SWC library. Consider leveraging an ${overlay.localName} directly.`,
          "https://opensource.adobe.com/spectrum-web-components/components/overlay/",
          { level: "deprecation" }
        );
      }
      const trigger = triggerOrContent;
      const interaction = interactionOrOptions;
      const options2 = optionsV1;
      AbstractOverlay.applyOptions(overlay, {
        ...options2,
        delayed: options2.delayed || overlayContent.hasAttribute("delayed"),
        trigger: options2.virtualTrigger || trigger,
        type: interaction === "modal" ? "modal" : interaction === "hover" ? "hint" : "auto"
      });
      trigger.insertAdjacentElement("afterend", overlay);
      await overlay.updateComplete;
      overlay.open = true;
      return overlay.dispose;
    }
    const options = interactionOrOptions;
    overlay.append(overlayContent);
    AbstractOverlay.applyOptions(overlay, {
      ...options,
      delayed: options.delayed || overlayContent.hasAttribute("delayed")
    });
    overlay.updateComplete.then(() => {
      overlay.open = true;
    });
    return overlay;
  }
  static applyOptions(overlay, options) {
    var _a, _b;
    overlay.delayed = !!options.delayed;
    overlay.receivesFocus = (_a = options.receivesFocus) != null ? _a : "auto";
    overlay.triggerElement = options.trigger || null;
    overlay.type = options.type || "modal";
    overlay.offset = (_b = options.offset) != null ? _b : 0;
    overlay.placement = options.placement;
    overlay.willPreventClose = !!options.notImmediatelyClosable;
  }
}
//# sourceMappingURL=AbstractOverlay.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/ClickController.dev.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/ClickController.dev.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClickController: () => (/* binding */ ClickController)
/* harmony export */ });
/* harmony import */ var _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractionController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js");


class ClickController extends _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_0__.InteractionController {
  constructor() {
    super(...arguments);
    this.type = _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_0__.InteractionTypes.click;
    /**
     * An overlay with a `click` interaction should not close on click `triggerElement`.
     * When a click is initiated (`pointerdown`), apply `preventNextToggle` when the
     * overlay is `open` to prevent from toggling the overlay when the click event
     * propagates later in the interaction.
     */
    this.preventNextToggle = false;
  }
  handleClick() {
    if (!this.preventNextToggle) {
      this.open = !this.open;
    }
    this.preventNextToggle = false;
  }
  handlePointerdown() {
    this.preventNextToggle = this.open;
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener("click", () => this.handleClick(), {
      signal
    });
    this.target.addEventListener(
      "pointerdown",
      () => this.handlePointerdown(),
      { signal }
    );
  }
}
//# sourceMappingURL=ClickController.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/HoverController.dev.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/HoverController.dev.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HoverController: () => (/* binding */ HoverController)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base_src_condition_attribute_with_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base/src/condition-attribute-with-id.js */ "./node_modules/@spectrum-web-components/base/src/condition-attribute-with-id.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @spectrum-web-components/shared/src/random-id.js */ "./node_modules/@spectrum-web-components/shared/src/random-id.dev.js");
/* harmony import */ var _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InteractionController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");





const HOVER_DELAY = 300;
class HoverController extends _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_2__.InteractionController {
  constructor() {
    super(...arguments);
    this.type = _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_2__.InteractionTypes.hover;
    this.elementIds = [];
    this.focusedin = false;
    this.pointerentered = false;
  }
  handleTargetFocusin() {
    var _a;
    if (!((_a = document.activeElement) == null ? void 0 : _a.matches(":focus-visible"))) {
      return;
    }
    this.open = true;
    this.focusedin = true;
  }
  handleTargetFocusout() {
    this.focusedin = false;
    if (this.pointerentered)
      return;
    this.open = false;
  }
  handleTargetPointerenter() {
    var _a;
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
    }
    if ((_a = this.overlay) == null ? void 0 : _a.disabled)
      return;
    this.open = true;
    this.pointerentered = true;
  }
  handleTargetPointerleave() {
    this.doPointerleave();
  }
  // set a timeout once the pointer enters and the overlay is shown
  // give the user time to enter the overlay
  handleHostPointerenter() {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
    }
  }
  handleHostPointerleave() {
    this.doPointerleave();
  }
  prepareDescription() {
    if (!this.overlay.elements.length)
      return;
    const triggerRoot = this.target.getRootNode();
    const contentRoot = this.overlay.elements[0].getRootNode();
    const overlayRoot = this.overlay.getRootNode();
    if (triggerRoot === overlayRoot) {
      this.prepareOverlayRelativeDescription();
    } else if (triggerRoot === contentRoot) {
      this.prepareContentRelativeDescription();
    }
  }
  prepareOverlayRelativeDescription() {
    const releaseDescription = (0,_spectrum_web_components_base_src_condition_attribute_with_id_js__WEBPACK_IMPORTED_MODULE_0__.conditionAttributeWithId)(
      this.target,
      "aria-describedby",
      [this.overlay.id]
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.releaseDescription = _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__.noop;
    };
  }
  prepareContentRelativeDescription() {
    const elementIds = [];
    const appliedIds = this.overlay.elements.map((el) => {
      elementIds.push(el.id);
      if (!el.id) {
        el.id = `${this.overlay.tagName.toLowerCase()}-helper-${(0,_spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_1__.randomID)()}`;
      }
      return el.id;
    });
    this.elementIds = elementIds;
    const releaseDescription = (0,_spectrum_web_components_base_src_condition_attribute_with_id_js__WEBPACK_IMPORTED_MODULE_0__.conditionAttributeWithId)(
      this.target,
      "aria-describedby",
      appliedIds
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.overlay.elements.map((el, index) => {
        el.id = this.elementIds[index];
      });
      this.releaseDescription = _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__.noop;
    };
  }
  doPointerleave() {
    this.pointerentered = false;
    const triggerElement = this.target;
    if (this.focusedin && triggerElement.matches(":focus-visible"))
      return;
    this.hoverTimeout = setTimeout(() => {
      this.open = false;
    }, HOVER_DELAY);
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener(
      "focusin",
      () => this.handleTargetFocusin(),
      { signal }
    );
    this.target.addEventListener(
      "focusout",
      () => this.handleTargetFocusout(),
      { signal }
    );
    this.target.addEventListener(
      "pointerenter",
      () => this.handleTargetPointerenter(),
      { signal }
    );
    this.target.addEventListener(
      "pointerleave",
      () => this.handleTargetPointerleave(),
      { signal }
    );
    if (this.overlay) {
      this.initOverlay();
    }
  }
  initOverlay() {
    if (!this.abortController) {
      return;
    }
    const { signal } = this.abortController;
    this.overlay.addEventListener(
      "pointerenter",
      () => this.handleHostPointerenter(),
      { signal }
    );
    this.overlay.addEventListener(
      "pointerleave",
      () => this.handleHostPointerleave(),
      { signal }
    );
  }
}
//# sourceMappingURL=HoverController.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InteractionController: () => (/* binding */ InteractionController),
/* harmony export */   InteractionTypes: () => (/* binding */ InteractionTypes)
/* harmony export */ });

var InteractionTypes = /* @__PURE__ */ ((InteractionTypes2) => {
  InteractionTypes2[InteractionTypes2["click"] = 0] = "click";
  InteractionTypes2[InteractionTypes2["hover"] = 1] = "hover";
  InteractionTypes2[InteractionTypes2["longpress"] = 2] = "longpress";
  return InteractionTypes2;
})(InteractionTypes || {});
class InteractionController {
  constructor(target, { overlay, isPersistent, handleOverlayReady }) {
    this.target = target;
    this.isPersistent = false;
    this.isPersistent = !!isPersistent;
    this.handleOverlayReady = handleOverlayReady;
    if (this.isPersistent) {
      this.init();
    }
    this.overlay = overlay;
  }
  get activelyOpening() {
    return false;
  }
  get open() {
    var _a, _b;
    return (_b = (_a = this.overlay) == null ? void 0 : _a.open) != null ? _b : false;
  }
  /**
   * Set `open` against the associated Overlay lazily.
   */
  set open(open) {
    if (this.overlay) {
      this.overlay.open = open;
      return;
    }
    if (!open) {
      return;
    }
    customElements.whenDefined("sp-overlay").then(async () => {
      const { Overlay } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./Overlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/Overlay.dev.js"));
      this.overlay = new Overlay();
      this.overlay.open = true;
    });
    Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @spectrum-web-components/overlay/sp-overlay.js */ "./node_modules/@spectrum-web-components/overlay/sp-overlay.dev.js"));
  }
  get overlay() {
    return this._overlay;
  }
  set overlay(overlay) {
    var _a;
    if (!overlay)
      return;
    if (this.overlay === overlay)
      return;
    if (this.overlay) {
      this.overlay.removeController(this);
    }
    this._overlay = overlay;
    this.overlay.addController(this);
    this.initOverlay();
    this.prepareDescription(this.target);
    (_a = this.handleOverlayReady) == null ? void 0 : _a.call(this, this.overlay);
  }
  prepareDescription(_) {
  }
  releaseDescription() {
  }
  shouldCompleteOpen() {
  }
  /* c8 ignore next 3 */
  init() {
  }
  /* c8 ignore next 3 */
  initOverlay() {
  }
  abort() {
    var _a;
    this.releaseDescription();
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  hostConnected() {
    this.init();
  }
  hostDisconnected() {
    if (!this.isPersistent) {
      this.abort();
    }
  }
}
//# sourceMappingURL=InteractionController.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/LongpressController.dev.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/LongpressController.dev.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LONGPRESS_INSTRUCTIONS: () => (/* binding */ LONGPRESS_INSTRUCTIONS),
/* harmony export */   LongpressController: () => (/* binding */ LongpressController)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_shared_src_platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/shared/src/platform.js */ "./node_modules/@spectrum-web-components/shared/src/platform.dev.js");
/* harmony import */ var _spectrum_web_components_base_src_condition_attribute_with_id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @spectrum-web-components/base/src/condition-attribute-with-id.js */ "./node_modules/@spectrum-web-components/base/src/condition-attribute-with-id.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @spectrum-web-components/shared/src/random-id.js */ "./node_modules/@spectrum-web-components/shared/src/random-id.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");
/* harmony import */ var _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./InteractionController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js");






const LONGPRESS_DURATION = 300;
const LONGPRESS_INSTRUCTIONS = {
  touch: "Double tap and long press for additional options",
  keyboard: "Press Space or Alt+Down Arrow for additional options",
  mouse: "Click and hold for additional options"
};
class LongpressController extends _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_4__.InteractionController {
  constructor() {
    super(...arguments);
    this.type = _InteractionController_dev_js__WEBPACK_IMPORTED_MODULE_4__.InteractionTypes.longpress;
    this.longpressState = null;
    this.releaseDescription = _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__.noop;
    this.handlePointerup = () => {
      var _a;
      clearTimeout(this.timeout);
      if (!this.target)
        return;
      this.longpressState = ((_a = this.overlay) == null ? void 0 : _a.state) === "opening" ? "pressed" : null;
      document.removeEventListener("pointerup", this.handlePointerup);
      document.removeEventListener("pointercancel", this.handlePointerup);
    };
  }
  get activelyOpening() {
    return this.longpressState === "opening" || this.longpressState === "pressed";
  }
  handleLongpress() {
    this.open = true;
    this.longpressState = this.longpressState === "potential" ? "opening" : "pressed";
  }
  handlePointerdown(event) {
    if (!this.target)
      return;
    if (event.button !== 0)
      return;
    this.longpressState = "potential";
    document.addEventListener("pointerup", this.handlePointerup);
    document.addEventListener("pointercancel", this.handlePointerup);
    const triggerHandlesLongpress = "holdAffordance" in this.target;
    if (triggerHandlesLongpress)
      return;
    this.timeout = setTimeout(() => {
      if (!this.target)
        return;
      this.target.dispatchEvent(
        new CustomEvent("longpress", {
          bubbles: true,
          composed: true,
          detail: {
            source: "pointer"
          }
        })
      );
    }, LONGPRESS_DURATION);
  }
  handleKeydown(event) {
    const { code, altKey } = event;
    if (altKey && code === "ArrowDown") {
      event.stopPropagation();
      event.stopImmediatePropagation();
    }
  }
  handleKeyup(event) {
    const { code, altKey } = event;
    if (code === "Space" || altKey && code === "ArrowDown") {
      if (!this.target) {
        return;
      }
      event.stopPropagation();
      this.target.dispatchEvent(
        new CustomEvent("longpress", {
          bubbles: true,
          composed: true,
          detail: {
            source: "keyboard"
          }
        })
      );
      setTimeout(() => {
        this.longpressState = null;
      });
    }
  }
  prepareDescription(trigger) {
    if (
      // do not reapply until target is recycled
      this.releaseDescription !== _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__.noop || // require "longpress content" to apply relationship
      !this.overlay.elements.length
    ) {
      return;
    }
    const longpressDescription = document.createElement("div");
    longpressDescription.id = `longpress-describedby-descriptor-${(0,_spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_2__.randomID)()}`;
    const messageType = (0,_spectrum_web_components_shared_src_platform_js__WEBPACK_IMPORTED_MODULE_0__.isIOS)() || (0,_spectrum_web_components_shared_src_platform_js__WEBPACK_IMPORTED_MODULE_0__.isAndroid)() ? "touch" : "keyboard";
    longpressDescription.textContent = LONGPRESS_INSTRUCTIONS[messageType];
    longpressDescription.slot = "longpress-describedby-descriptor";
    const triggerParent = trigger.getRootNode();
    const overlayParent = this.overlay.getRootNode();
    if (triggerParent === overlayParent) {
      this.overlay.append(longpressDescription);
    } else {
      longpressDescription.hidden = !("host" in triggerParent);
      trigger.insertAdjacentElement("afterend", longpressDescription);
    }
    const releaseDescription = (0,_spectrum_web_components_base_src_condition_attribute_with_id_js__WEBPACK_IMPORTED_MODULE_1__.conditionAttributeWithId)(
      trigger,
      "aria-describedby",
      [longpressDescription.id]
    );
    this.releaseDescription = () => {
      releaseDescription();
      longpressDescription.remove();
      this.releaseDescription = _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_3__.noop;
    };
  }
  shouldCompleteOpen() {
    this.longpressState = this.longpressState === "pressed" ? null : this.longpressState;
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener(
      "longpress",
      () => this.handleLongpress(),
      { signal }
    );
    this.target.addEventListener(
      "pointerdown",
      (event) => this.handlePointerdown(event),
      { signal }
    );
    this.prepareDescription(this.target);
    if (this.target.holdAffordance) {
      return;
    }
    this.target.addEventListener(
      "keydown",
      (event) => this.handleKeydown(event),
      { signal }
    );
    this.target.addEventListener(
      "keyup",
      (event) => this.handleKeyup(event),
      { signal }
    );
  }
}
//# sourceMappingURL=LongpressController.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/Overlay.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/Overlay.dev.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LONGPRESS_INSTRUCTIONS: () => (/* reexport safe */ _LongpressController_dev_js__WEBPACK_IMPORTED_MODULE_12__.LONGPRESS_INSTRUCTIONS),
/* harmony export */   Overlay: () => (/* binding */ Overlay)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/index.dev.js");
/* harmony import */ var _spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @spectrum-web-components/base/src/decorators.js */ "./node_modules/@spectrum-web-components/base/src/decorators.dev.js");
/* harmony import */ var _spectrum_web_components_reactive_controllers_src_ElementResolution_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @spectrum-web-components/reactive-controllers/src/ElementResolution.js */ "./node_modules/@spectrum-web-components/reactive-controllers/src/ElementResolution.dev.js");
/* harmony import */ var _spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @spectrum-web-components/base/src/directives.js */ "./node_modules/@spectrum-web-components/base/src/directives.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared/src/random-id.js */ "./node_modules/@spectrum-web-components/shared/src/random-id.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");
/* harmony import */ var _OverlayDialog_dev_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./OverlayDialog.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/OverlayDialog.dev.js");
/* harmony import */ var _OverlayPopover_dev_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./OverlayPopover.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/OverlayPopover.dev.js");
/* harmony import */ var _OverlayNoPopover_dev_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./OverlayNoPopover.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.dev.js");
/* harmony import */ var _OverlayStack_dev_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./OverlayStack.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/OverlayStack.dev.js");
/* harmony import */ var _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./VirtualTrigger.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js");
/* harmony import */ var _PlacementController_dev_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PlacementController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/PlacementController.dev.js");
/* harmony import */ var _LongpressController_dev_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./LongpressController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/LongpressController.dev.js");
/* harmony import */ var _strategies_dev_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./strategies.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/strategies.dev.js");
/* harmony import */ var _slottable_request_event_dev_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./slottable-request-event.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/slottable-request-event.dev.js");
/* harmony import */ var _overlay_css_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./overlay.css.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay.css.js");

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
















const supportsPopover = "showPopover" in document.createElement("div");
let OverlayFeatures = (0,_OverlayDialog_dev_js__WEBPACK_IMPORTED_MODULE_6__.OverlayDialog)(_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_5__.AbstractOverlay);
if (supportsPopover) {
  OverlayFeatures = (0,_OverlayPopover_dev_js__WEBPACK_IMPORTED_MODULE_7__.OverlayPopover)(OverlayFeatures);
} else {
  OverlayFeatures = (0,_OverlayNoPopover_dev_js__WEBPACK_IMPORTED_MODULE_8__.OverlayNoPopover)(OverlayFeatures);
}
const _Overlay = class _Overlay extends OverlayFeatures {
  constructor() {
    super(...arguments);
    this._delayed = false;
    this._disabled = false;
    this.offset = 0;
    this._open = false;
    /**
     * The state in which the last `request-slottable` event was dispatched.
     * Do not allow overlays from dispatching the same state twice in a row.
     */
    this.lastRequestSlottableState = false;
    this.receivesFocus = "auto";
    this._state = "closed";
    this.triggerElement = null;
    this.type = "auto";
    this.wasOpen = false;
    this.closeOnFocusOut = (event) => {
      if (!event.relatedTarget) {
        return;
      }
      const relationEvent = new Event("overlay-relation-query", {
        bubbles: true,
        composed: true
      });
      event.relatedTarget.addEventListener(
        relationEvent.type,
        (event2) => {
          if (!event2.composedPath().includes(this)) {
            this.open = false;
          }
        }
      );
      event.relatedTarget.dispatchEvent(relationEvent);
    };
  }
  get delayed() {
    var _a;
    return ((_a = this.elements.at(-1)) == null ? void 0 : _a.hasAttribute("delayed")) || this._delayed;
  }
  set delayed(delayed) {
    this._delayed = delayed;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    var _a;
    this._disabled = disabled;
    if (disabled) {
      (_a = this.strategy) == null ? void 0 : _a.abort();
      this.wasOpen = this.open;
      this.open = false;
    } else {
      this.bindEvents();
      this.open = this.open || this.wasOpen;
      this.wasOpen = false;
    }
  }
  get hasNonVirtualTrigger() {
    return !!this.triggerElement && !(this.triggerElement instanceof _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_10__.VirtualTrigger);
  }
  get placementController() {
    if (!this._placementController) {
      this._placementController = new _PlacementController_dev_js__WEBPACK_IMPORTED_MODULE_11__.PlacementController(this);
    }
    return this._placementController;
  }
  get open() {
    return this._open;
  }
  set open(open) {
    var _a;
    if (open && this.disabled)
      return;
    if (open === this.open)
      return;
    if (((_a = this.strategy) == null ? void 0 : _a.activelyOpening) && !open)
      return;
    this._open = open;
    if (this.open) {
      _Overlay.openCount += 1;
    }
    this.requestUpdate("open", !this.open);
    if (this.open) {
      this.requestSlottable();
    }
  }
  get state() {
    return this._state;
  }
  set state(state2) {
    var _a;
    if (state2 === this.state)
      return;
    const oldState = this.state;
    this._state = state2;
    if (this.state === "opened" || this.state === "closed") {
      (_a = this.strategy) == null ? void 0 : _a.shouldCompleteOpen();
    }
    this.requestUpdate("state", oldState);
  }
  get elementResolver() {
    if (!this._elementResolver) {
      this._elementResolver = new _spectrum_web_components_reactive_controllers_src_ElementResolution_js__WEBPACK_IMPORTED_MODULE_2__.ElementResolutionController(this);
    }
    return this._elementResolver;
  }
  get usesDialog() {
    return this.type === "modal" || this.type === "page";
  }
  get popoverValue() {
    const hasPopoverAttribute = "popover" in this;
    if (!hasPopoverAttribute) {
      return void 0;
    }
    switch (this.type) {
      case "modal":
      case "page":
        return void 0;
      case "hint":
        return "manual";
      default:
        return this.type;
    }
  }
  get requiresPosition() {
    if (this.type === "page" || !this.open)
      return false;
    if (!this.triggerElement || !this.placement && this.type !== "hint")
      return false;
    return true;
  }
  managePosition() {
    if (!this.requiresPosition || !this.open)
      return;
    const offset = this.offset || 0;
    const trigger = this.triggerElement;
    const placement = this.placement || "right";
    const tipPadding = this.tipPadding;
    this.placementController.placeOverlay(this.dialogEl, {
      offset,
      placement,
      tipPadding,
      trigger,
      type: this.type
    });
  }
  async managePopoverOpen() {
    super.managePopoverOpen();
    const targetOpenState = this.open;
    if (this.open !== targetOpenState) {
      return;
    }
    await this.manageDelay(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    await this.ensureOnDOM(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    const focusEl = await this.makeTransition(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    await this.applyFocus(targetOpenState, focusEl);
  }
  async applyFocus(targetOpenState, focusEl) {
    if (this.receivesFocus === "false" || this.type === "hint") {
      return;
    }
    await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_5__.nextFrame)();
    await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_5__.nextFrame)();
    if (targetOpenState === this.open && !this.open) {
      if (this.hasNonVirtualTrigger && this.contains(this.getRootNode().activeElement)) {
        this.triggerElement.focus();
      }
      return;
    }
    focusEl == null ? void 0 : focusEl.focus();
  }
  returnFocus() {
    var _a;
    if (this.open || this.type === "hint")
      return;
    const getAncestors = () => {
      var _a2, _b;
      const ancestors = [];
      let currentNode = document.activeElement;
      while ((_a2 = currentNode == null ? void 0 : currentNode.shadowRoot) == null ? void 0 : _a2.activeElement) {
        currentNode = currentNode.shadowRoot.activeElement;
      }
      while (currentNode) {
        const ancestor = currentNode.assignedSlot || currentNode.parentElement || ((_b = currentNode.getRootNode()) == null ? void 0 : _b.host);
        if (ancestor) {
          ancestors.push(ancestor);
        }
        currentNode = ancestor;
      }
      return ancestors;
    };
    if (this.receivesFocus !== "false" && ((_a = this.triggerElement) == null ? void 0 : _a.focus) && (this.contains(this.getRootNode().activeElement) || getAncestors().includes(this) || // eslint-disable-next-line @spectrum-web-components/document-active-element
    document.activeElement === document.body)) {
      this.triggerElement.focus();
    }
  }
  async manageOpen(oldOpen) {
    if (!this.isConnected && this.open)
      return;
    if (!this.hasUpdated) {
      await this.updateComplete;
    }
    if (this.open) {
      _OverlayStack_dev_js__WEBPACK_IMPORTED_MODULE_9__.overlayStack.add(this);
      if (this.willPreventClose) {
        document.addEventListener(
          "pointerup",
          () => {
            this.dialogEl.classList.toggle(
              "not-immediately-closable",
              false
            );
            this.willPreventClose = false;
          },
          { once: true }
        );
        this.dialogEl.classList.toggle(
          "not-immediately-closable",
          true
        );
      }
    } else {
      if (oldOpen) {
        this.dispose();
      }
      _OverlayStack_dev_js__WEBPACK_IMPORTED_MODULE_9__.overlayStack.remove(this);
    }
    if (this.open && this.state !== "opened") {
      this.state = "opening";
    } else if (!this.open && this.state !== "closed") {
      this.state = "closing";
    }
    if (this.usesDialog) {
      this.manageDialogOpen();
    } else {
      this.managePopoverOpen();
    }
    if (this.type === "auto") {
      const listenerRoot = this.getRootNode();
      if (this.open) {
        listenerRoot.addEventListener(
          "focusout",
          this.closeOnFocusOut,
          { capture: true }
        );
      } else {
        listenerRoot.removeEventListener(
          "focusout",
          this.closeOnFocusOut,
          { capture: true }
        );
      }
    }
  }
  bindEvents() {
    var _a;
    (_a = this.strategy) == null ? void 0 : _a.abort();
    this.strategy = void 0;
    if (!this.hasNonVirtualTrigger)
      return;
    if (!this.triggerInteraction)
      return;
    this.strategy = new _strategies_dev_js__WEBPACK_IMPORTED_MODULE_13__.strategies[this.triggerInteraction](
      this.triggerElement,
      {
        overlay: this
      }
    );
  }
  handleBeforetoggle(event) {
    if (event.newState !== "open") {
      this.handleBrowserClose();
    }
  }
  handleBrowserClose() {
    var _a;
    if (!((_a = this.strategy) == null ? void 0 : _a.activelyOpening)) {
      this.open = false;
      return;
    }
    this.manuallyKeepOpen();
  }
  manuallyKeepOpen() {
    this.open = true;
    this.placementController.allowPlacementUpdate = true;
    this.manageOpen(false);
  }
  handleSlotchange() {
    var _a, _b;
    if (!this.elements.length) {
      (_a = this.strategy) == null ? void 0 : _a.releaseDescription();
    } else if (this.hasNonVirtualTrigger) {
      (_b = this.strategy) == null ? void 0 : _b.prepareDescription(
        this.triggerElement
      );
    }
  }
  shouldPreventClose() {
    const shouldPreventClose = this.willPreventClose;
    this.willPreventClose = false;
    return shouldPreventClose;
  }
  requestSlottable() {
    if (this.lastRequestSlottableState === this.open) {
      return;
    }
    if (!this.open) {
      document.body.offsetHeight;
    }
    this.dispatchEvent(
      new _slottable_request_event_dev_js__WEBPACK_IMPORTED_MODULE_14__.SlottableRequestEvent(
        "overlay-content",
        this.open ? {} : _slottable_request_event_dev_js__WEBPACK_IMPORTED_MODULE_14__.removeSlottableRequest
      )
    );
    this.lastRequestSlottableState = this.open;
  }
  willUpdate(changes) {
    var _a;
    if (!this.hasAttribute("id")) {
      this.setAttribute(
        "id",
        `${this.tagName.toLowerCase()}-${(0,_spectrum_web_components_shared_src_random_id_js__WEBPACK_IMPORTED_MODULE_4__.randomID)()}`
      );
    }
    if (changes.has("open") && (this.hasUpdated || this.open)) {
      this.manageOpen(changes.get("open"));
    }
    if (changes.has("trigger")) {
      const [id, interaction] = ((_a = this.trigger) == null ? void 0 : _a.split("@")) || [];
      this.elementResolver.selector = id ? `#${id}` : "";
      this.triggerInteraction = interaction;
    }
    let oldTrigger = false;
    if (changes.has(_spectrum_web_components_reactive_controllers_src_ElementResolution_js__WEBPACK_IMPORTED_MODULE_2__.elementResolverUpdatedSymbol)) {
      oldTrigger = this.triggerElement;
      this.triggerElement = this.elementResolver.element;
    }
    if (changes.has("triggerElement")) {
      oldTrigger = changes.get("triggerElement");
    }
    if (oldTrigger !== false) {
      this.bindEvents();
    }
  }
  updated(changes) {
    super.updated(changes);
    if (changes.has("placement")) {
      if (this.placement) {
        this.dialogEl.setAttribute("actual-placement", this.placement);
      } else {
        this.dialogEl.removeAttribute("actual-placement");
      }
      if (this.open && typeof changes.get("placement") !== "undefined") {
        this.placementController.resetOverlayPosition();
      }
    }
    if (changes.has("state") && this.state === "closed" && typeof changes.get("state") !== "undefined") {
      this.placementController.clearOverlayPosition();
    }
  }
  renderContent() {
    return (0,_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html)`
            <slot @slotchange=${this.handleSlotchange}></slot>
        `;
  }
  get dialogStyleMap() {
    return {
      "--swc-overlay-open-count": _Overlay.openCount.toString()
    };
  }
  renderDialog() {
    return (0,_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html)`
            <dialog
                class="dialog"
                part="dialog"
                placement=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__.ifDefined)(
      this.requiresPosition ? this.placement || "right" : void 0
    )}
                style=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__.styleMap)(this.dialogStyleMap)}
                @close=${this.handleBrowserClose}
                @cancel=${this.handleBrowserClose}
                @beforetoggle=${this.handleBeforetoggle}
                ?is-visible=${this.state !== "closed"}
            >
                ${this.renderContent()}
            </dialog>
        `;
  }
  renderPopover() {
    return (0,_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html)`
            <div
                class="dialog"
                part="dialog"
                placement=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__.ifDefined)(
      this.requiresPosition ? this.placement || "right" : void 0
    )}
                popover=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__.ifDefined)(this.popoverValue)}
                style=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_3__.styleMap)(this.dialogStyleMap)}
                @beforetoggle=${this.handleBeforetoggle}
                @close=${this.handleBrowserClose}
                ?is-visible=${this.state !== "closed"}
            >
                ${this.renderContent()}
            </div>
        `;
  }
  render() {
    const isDialog = this.type === "modal" || this.type === "page";
    return (0,_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html)`
            ${isDialog ? this.renderDialog() : this.renderPopover()}
            <slot name="longpress-describedby-descriptor"></slot>
        `;
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("close", () => {
      this.open = false;
    });
    if (this.hasUpdated) {
      this.bindEvents();
    }
  }
  disconnectedCallback() {
    var _a;
    (_a = this.strategy) == null ? void 0 : _a.releaseDescription();
    this.open = false;
    super.disconnectedCallback();
  }
};
_Overlay.styles = [_overlay_css_js__WEBPACK_IMPORTED_MODULE_15__["default"]];
_Overlay.openCount = 1;
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })
], _Overlay.prototype, "delayed", 1);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.query)(".dialog")
], _Overlay.prototype, "dialogEl", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })
], _Overlay.prototype, "disabled", 1);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.queryAssignedElements)({
    flatten: true,
    selector: ':not([slot="longpress-describedby-descriptor"], slot)'
    // gather only elements slotted into the default slot
  })
], _Overlay.prototype, "elements", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })
], _Overlay.prototype, "offset", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean, reflect: true })
], _Overlay.prototype, "open", 1);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()
], _Overlay.prototype, "placement", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ attribute: "receives-focus" })
], _Overlay.prototype, "receivesFocus", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.query)("slot")
], _Overlay.prototype, "slotEl", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.state)()
], _Overlay.prototype, "state", 1);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number, attribute: "tip-padding" })
], _Overlay.prototype, "tipPadding", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()
], _Overlay.prototype, "trigger", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ attribute: false })
], _Overlay.prototype, "triggerElement", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ attribute: false })
], _Overlay.prototype, "triggerInteraction", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()
], _Overlay.prototype, "type", 2);
let Overlay = _Overlay;
//# sourceMappingURL=Overlay.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/OverlayDialog.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/OverlayDialog.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayDialog: () => (/* binding */ OverlayDialog)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/shared/src/first-focusable-in.js */ "./node_modules/@spectrum-web-components/shared/src/first-focusable-in.dev.js");
/* harmony import */ var _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VirtualTrigger.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");
/* harmony import */ var _events_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/events.dev.js");
/* harmony import */ var _spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared */ "./node_modules/@spectrum-web-components/shared/src/index.dev.js");






function OverlayDialog(constructor) {
  class OverlayWithDialog extends constructor {
    async manageDialogOpen() {
      const targetOpenState = this.open;
      await this.managePosition();
      if (this.open !== targetOpenState) {
        return;
      }
      const focusEl = await this.dialogMakeTransition(targetOpenState);
      if (this.open !== targetOpenState) {
        return;
      }
      await this.dialogApplyFocus(targetOpenState, focusEl);
    }
    async dialogMakeTransition(targetOpenState) {
      let focusEl = null;
      const start = (el, index) => async () => {
        el.open = targetOpenState;
        if (!targetOpenState) {
          const close = () => {
            el.removeEventListener("close", close);
            finish(el, index);
          };
          el.addEventListener("close", close);
        }
        if (index > 0) {
          return;
        }
        const event = targetOpenState ? _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleOpenEvent : _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleClosedEvent;
        this.dispatchEvent(new event());
        if (!targetOpenState) {
          return;
        }
        if (el.matches(_spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__.userFocusableSelector)) {
          focusEl = el;
        }
        focusEl = focusEl || (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableIn)(el);
        if (!focusEl) {
          const childSlots = el.querySelectorAll("slot");
          childSlots.forEach((slot) => {
            if (!focusEl) {
              focusEl = (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableSlottedIn)(slot);
            }
          });
        }
        if (!this.isConnected || this.dialogEl.open) {
          return;
        }
        this.dialogEl.showModal();
      };
      const finish = (el, index) => () => {
        if (this.open !== targetOpenState) {
          return;
        }
        const eventName = targetOpenState ? "sp-opened" : "sp-closed";
        if (index > 0) {
          el.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          return;
        }
        if (!this.isConnected || targetOpenState !== this.open) {
          return;
        }
        const reportChange = async () => {
          const hasVirtualTrigger = this.triggerElement instanceof _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__.VirtualTrigger;
          this.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: hasVirtualTrigger
            })
          );
          el.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          if (this.triggerElement && !hasVirtualTrigger) {
            this.triggerElement.dispatchEvent(
              new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
                interaction: this.type,
                publish: true
              })
            );
          }
          this.state = targetOpenState ? "opened" : "closed";
          this.returnFocus();
          await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
          await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
          if (targetOpenState === this.open && targetOpenState === false) {
            this.requestSlottable();
          }
        };
        if (!targetOpenState && this.dialogEl.open) {
          this.dialogEl.addEventListener(
            "close",
            () => {
              reportChange();
            },
            { once: true }
          );
          this.dialogEl.close();
        } else {
          reportChange();
        }
      };
      this.elements.forEach((el, index) => {
        (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.guaranteedAllTransitionend)(
          el,
          start(el, index),
          finish(el, index)
        );
      });
      return focusEl;
    }
    async dialogApplyFocus(targetOpenState, focusEl) {
      this.applyFocus(targetOpenState, focusEl);
    }
  }
  return OverlayWithDialog;
}
//# sourceMappingURL=OverlayDialog.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.dev.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.dev.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayNoPopover: () => (/* binding */ OverlayNoPopover)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/shared/src/first-focusable-in.js */ "./node_modules/@spectrum-web-components/shared/src/first-focusable-in.dev.js");
/* harmony import */ var _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VirtualTrigger.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");
/* harmony import */ var _events_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/events.dev.js");
/* harmony import */ var _spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared */ "./node_modules/@spectrum-web-components/shared/src/index.dev.js");






function OverlayNoPopover(constructor) {
  class OverlayWithNoPopover extends constructor {
    async managePopoverOpen() {
      await this.managePosition();
    }
    async manageDelay(targetOpenState) {
      if (targetOpenState === false || targetOpenState !== this.open) {
        _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.overlayTimer.close(this);
        return;
      }
      if (this.delayed) {
        const cancelled = await _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.overlayTimer.openTimer(this);
        if (cancelled) {
          this.open = !targetOpenState;
        }
      }
    }
    async ensureOnDOM(_targetOpenState) {
      document.body.offsetHeight;
    }
    async makeTransition(targetOpenState) {
      if (this.open !== targetOpenState) {
        return null;
      }
      let focusEl = null;
      const start = (el, index) => () => {
        if (targetOpenState !== this.open) {
          return;
        }
        el.open = targetOpenState;
        if (index === 0) {
          const event = targetOpenState ? _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleOpenEvent : _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleClosedEvent;
          this.dispatchEvent(new event());
        }
        if (targetOpenState !== true) {
          return;
        }
        if (el.matches(_spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__.userFocusableSelector)) {
          focusEl = el;
        }
        focusEl = focusEl || (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableIn)(el);
        if (focusEl) {
          return;
        }
        const childSlots = el.querySelectorAll("slot");
        childSlots.forEach((slot) => {
          if (!focusEl) {
            focusEl = (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableSlottedIn)(slot);
          }
        });
      };
      const finish = (el, index) => async () => {
        if (this.open !== targetOpenState) {
          return;
        }
        const eventName = targetOpenState ? "sp-opened" : "sp-closed";
        el.dispatchEvent(
          new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
            interaction: this.type
          })
        );
        if (index > 0) {
          return;
        }
        const hasVirtualTrigger = this.triggerElement instanceof _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__.VirtualTrigger;
        this.dispatchEvent(
          new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
            interaction: this.type,
            publish: hasVirtualTrigger
          })
        );
        if (this.triggerElement && !hasVirtualTrigger) {
          this.triggerElement.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: true
            })
          );
        }
        this.state = targetOpenState ? "opened" : "closed";
        this.returnFocus();
        await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
        await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
        if (targetOpenState === this.open && targetOpenState === false) {
          this.requestSlottable();
        }
      };
      this.elements.forEach((el, index) => {
        (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.guaranteedAllTransitionend)(
          el,
          start(el, index),
          finish(el, index)
        );
      });
      return focusEl;
    }
  }
  return OverlayWithNoPopover;
}
//# sourceMappingURL=OverlayNoPopover.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/OverlayPopover.dev.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/OverlayPopover.dev.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayPopover: () => (/* binding */ OverlayPopover)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/shared/src/first-focusable-in.js */ "./node_modules/@spectrum-web-components/shared/src/first-focusable-in.dev.js");
/* harmony import */ var _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VirtualTrigger.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js");
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");
/* harmony import */ var _events_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/events.dev.js");
/* harmony import */ var _spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared */ "./node_modules/@spectrum-web-components/shared/src/index.dev.js");






const supportsOverlayAuto = CSS.supports("(overlay: auto)");
function isOpen(el) {
  let popoverOpen = false;
  try {
    popoverOpen = el.matches(":popover-open");
  } catch (error) {
  }
  let open = false;
  try {
    open = el.matches(":open");
  } catch (error) {
  }
  return popoverOpen || open;
}
function OverlayPopover(constructor) {
  class OverlayWithPopover extends constructor {
    async manageDelay(targetOpenState) {
      if (targetOpenState === false || targetOpenState !== this.open) {
        _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.overlayTimer.close(this);
        return;
      }
      if (this.delayed) {
        const cancelled = await _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.overlayTimer.openTimer(this);
        if (cancelled) {
          this.open = !targetOpenState;
        }
      }
    }
    /**
     * A popover should be hidden _after_ it is no longer on top-layer because
     * the position metrics will have changed from when it was originally positioned.
     */
    async shouldHidePopover(targetOpenState) {
      if (targetOpenState && this.open !== targetOpenState) {
        return;
      }
      const update = async ({
        newState
      } = {}) => {
        if (newState === "open") {
          return;
        }
        await this.placementController.resetOverlayPosition();
      };
      if (!isOpen(this.dialogEl)) {
        update();
        return;
      }
      this.dialogEl.addEventListener("toggle", update, {
        once: true
      });
    }
    async shouldShowPopover(targetOpenState) {
      let popoverOpen = false;
      try {
        popoverOpen = this.dialogEl.matches(":popover-open");
      } catch (error) {
      }
      let open = false;
      try {
        open = this.dialogEl.matches(":open");
      } catch (error) {
      }
      if (targetOpenState && this.open === targetOpenState && !popoverOpen && !open && this.isConnected) {
        this.dialogEl.showPopover();
        await this.managePosition();
      }
    }
    async ensureOnDOM(targetOpenState) {
      await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
      if (!supportsOverlayAuto) {
        await this.shouldHidePopover(targetOpenState);
      }
      await this.shouldShowPopover(targetOpenState);
      await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
    }
    async makeTransition(targetOpenState) {
      if (this.open !== targetOpenState) {
        return null;
      }
      let focusEl = null;
      const start = (el, index) => () => {
        el.open = targetOpenState;
        if (index === 0) {
          const event = targetOpenState ? _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleOpenEvent : _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.BeforetoggleClosedEvent;
          this.dispatchEvent(new event());
        }
        if (!targetOpenState) {
          return;
        }
        if (el.matches(_spectrum_web_components_shared__WEBPACK_IMPORTED_MODULE_4__.userFocusableSelector)) {
          focusEl = el;
        }
        focusEl = focusEl || (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableIn)(el);
        if (focusEl) {
          return;
        }
        const childSlots = el.querySelectorAll("slot");
        childSlots.forEach((slot) => {
          if (!focusEl) {
            focusEl = (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_0__.firstFocusableSlottedIn)(slot);
          }
        });
      };
      const finish = (el, index) => async () => {
        if (this.open !== targetOpenState) {
          return;
        }
        const eventName = targetOpenState ? "sp-opened" : "sp-closed";
        if (index > 0) {
          el.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          return;
        }
        const reportChange = async () => {
          if (this.open !== targetOpenState) {
            return;
          }
          await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
          const hasVirtualTrigger = this.triggerElement instanceof _VirtualTrigger_dev_js__WEBPACK_IMPORTED_MODULE_1__.VirtualTrigger;
          this.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: hasVirtualTrigger
            })
          );
          el.dispatchEvent(
            new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          if (this.triggerElement && !hasVirtualTrigger) {
            this.triggerElement.dispatchEvent(
              new _events_dev_js__WEBPACK_IMPORTED_MODULE_3__.OverlayStateEvent(eventName, this, {
                interaction: this.type,
                publish: true
              })
            );
          }
          this.state = targetOpenState ? "opened" : "closed";
          this.returnFocus();
          await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
          await (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.nextFrame)();
          if (targetOpenState === this.open && targetOpenState === false) {
            this.requestSlottable();
          }
        };
        if (this.open !== targetOpenState) {
          return;
        }
        const open = isOpen(this.dialogEl);
        if (targetOpenState !== true && open && this.isConnected) {
          this.dialogEl.addEventListener(
            "beforetoggle",
            () => {
              reportChange();
            },
            { once: true }
          );
          this.dialogEl.hidePopover();
        } else {
          reportChange();
        }
      };
      this.elements.forEach((el, index) => {
        (0,_AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_2__.guaranteedAllTransitionend)(
          el,
          start(el, index),
          finish(el, index)
        );
      });
      return focusEl;
    }
  }
  return OverlayWithPopover;
}
//# sourceMappingURL=OverlayPopover.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/OverlayStack.dev.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/OverlayStack.dev.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   overlayStack: () => (/* binding */ overlayStack)
/* harmony export */ });

const supportsPopover = "showPopover" in document.createElement("div");
class OverlayStack {
  constructor() {
    this.root = document.body;
    this.stack = [];
    /**
     * Cach the `pointerdownTarget` for later testing
     *
     * @param event {ClickEvent}
     */
    this.handlePointerdown = (event) => {
      this.pointerdownPath = event.composedPath();
      this.lastOverlay = this.stack.at(-1);
    };
    /**
     * Close all overlays that are not ancestors of this click event
     *
     * @param event {ClickEvent}
     */
    this.handlePointerup = () => {
      var _a;
      if (!this.stack.length)
        return;
      if (!((_a = this.pointerdownPath) == null ? void 0 : _a.length))
        return;
      const composedPath = this.pointerdownPath;
      this.pointerdownPath = void 0;
      const lastIndex = this.stack.length - 1;
      const nonAncestorOverlays = this.stack.filter((overlay, i) => {
        const inStack = composedPath.find(
          (el) => (
            // The Overlay is in the stack
            el === overlay || // The Overlay trigger is in the stack and the Overlay is a "hint"
            el === (overlay == null ? void 0 : overlay.triggerElement) && "hint" === (overlay == null ? void 0 : overlay.type) || // The last Overlay in the stack is not the last Overlay at `pointerdown` time and has a
            // `triggerInteraction` of "longpress", meaning it was opened by this poitner interaction
            i === lastIndex && overlay !== this.lastOverlay && overlay.triggerInteraction === "longpress"
          )
        );
        return !inStack && !overlay.shouldPreventClose() && overlay.type !== "manual";
      });
      nonAncestorOverlays.reverse();
      nonAncestorOverlays.forEach((overlay) => {
        this.closeOverlay(overlay);
        let parentToClose = overlay.parentOverlayToForceClose;
        while (parentToClose) {
          this.closeOverlay(parentToClose);
          parentToClose = parentToClose.parentOverlayToForceClose;
        }
      });
    };
    this.handleBeforetoggle = (event) => {
      const { target, newState: open } = event;
      if (open === "open")
        return;
      this.closeOverlay(target);
    };
    this.handleKeydown = (event) => {
      if (event.code !== "Escape")
        return;
      if (!this.stack.length)
        return;
      const last = this.stack.at(-1);
      if ((last == null ? void 0 : last.type) === "page") {
        event.preventDefault();
        return;
      }
      if (supportsPopover)
        return;
      if ((last == null ? void 0 : last.type) === "manual") {
        return;
      }
      if (!last)
        return;
      this.closeOverlay(last);
    };
    this.bindEvents();
  }
  get document() {
    return this.root.ownerDocument || document;
  }
  bindEvents() {
    this.document.addEventListener("pointerdown", this.handlePointerdown);
    this.document.addEventListener("pointerup", this.handlePointerup);
    this.document.addEventListener("keydown", this.handleKeydown);
  }
  closeOverlay(overlay) {
    const overlayIndex = this.stack.indexOf(overlay);
    if (overlayIndex > -1) {
      this.stack.splice(overlayIndex, 1);
    }
    overlay.open = false;
  }
  /**
   * Get an array of Overlays that all share the same trigger element.
   *
   * @param triggerElement {HTMLELement}
   * @returns {Overlay[]}
   */
  overlaysByTriggerElement(triggerElement) {
    return this.stack.filter(
      (overlay) => overlay.triggerElement === triggerElement
    );
  }
  /**
   * When overlays are added manage the open state of exisiting overlays appropriately:
   * - 'modal': should close other overlays
   * - 'page': should close other overlays
   * - 'auto': should close other 'auto' overlays and other 'hint' overlays, but not 'manual' overlays
   * - 'manual': shouldn't close other overlays
   * - 'hint': shouldn't close other overlays and give way to all other overlays on a trigger
   */
  add(overlay) {
    if (this.stack.includes(overlay)) {
      const overlayIndex = this.stack.indexOf(overlay);
      if (overlayIndex > -1) {
        this.stack.splice(overlayIndex, 1);
        this.stack.push(overlay);
      }
      return;
    }
    if (overlay.type === "auto" || overlay.type === "modal" || overlay.type === "page") {
      const queryPathEventName = "sp-overlay-query-path";
      const queryPathEvent = new Event(queryPathEventName, {
        composed: true,
        bubbles: true
      });
      overlay.addEventListener(
        queryPathEventName,
        (event) => {
          const path = event.composedPath();
          this.stack.forEach((overlayEl) => {
            const inPath = path.find((el) => el === overlayEl);
            if (!inPath && overlayEl.type !== "manual") {
              this.closeOverlay(overlayEl);
            }
          });
        },
        { once: true }
      );
      overlay.dispatchEvent(queryPathEvent);
    } else if (overlay.type === "hint") {
      const hasPrevious = this.stack.some((overlayEl) => {
        return overlayEl.type !== "manual" && overlayEl.triggerElement && overlayEl.triggerElement === overlay.triggerElement;
      });
      if (hasPrevious) {
        overlay.open = false;
        return;
      }
      this.stack.forEach((overlayEl) => {
        if (overlayEl.type === "hint") {
          this.closeOverlay(overlayEl);
        }
      });
    }
    requestAnimationFrame(() => {
      this.stack.push(overlay);
      overlay.addEventListener("beforetoggle", this.handleBeforetoggle, {
        once: true
      });
    });
  }
  remove(overlay) {
    this.closeOverlay(overlay);
  }
}
const overlayStack = new OverlayStack();
//# sourceMappingURL=OverlayStack.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/PlacementController.dev.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/PlacementController.dev.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlacementController: () => (/* binding */ PlacementController),
/* harmony export */   placementUpdatedSymbol: () => (/* binding */ placementUpdatedSymbol)
/* harmony export */ });
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs");


function roundByDPR(num) {
  if (typeof num === "undefined")
    return 0;
  const dpr = window.devicePixelRatio || 1;
  return Math.round(num * dpr) / dpr;
}
const REQUIRED_DISTANCE_TO_EDGE = 8;
const MIN_OVERLAY_HEIGHT = 100;
const getFallbackPlacements = (placement) => {
  var _a;
  const fallbacks = {
    left: ["right", "bottom", "top"],
    "left-start": ["right-start", "bottom", "top"],
    "left-end": ["right-end", "bottom", "top"],
    right: ["left", "bottom", "top"],
    "right-start": ["left-start", "bottom", "top"],
    "right-end": ["left-end", "bottom", "top"],
    top: ["bottom", "left", "right"],
    "top-start": ["bottom-start", "left", "right"],
    "top-end": ["bottom-end", "left", "right"],
    bottom: ["top", "left", "right"],
    "bottom-start": ["top-start", "left", "right"],
    "bottom-end": ["top-end", "left", "right"]
  };
  return (_a = fallbacks[placement]) != null ? _a : [placement];
};
const placementUpdatedSymbol = Symbol("placement updated");
class PlacementController {
  constructor(host) {
    this.originalPlacements = /* @__PURE__ */ new WeakMap();
    this.allowPlacementUpdate = false;
    this.closeForAncestorUpdate = () => {
      if (!this.allowPlacementUpdate && this.options.type !== "modal" && this.cleanup) {
        this.target.dispatchEvent(new Event("close", { bubbles: true }));
      }
      this.allowPlacementUpdate = false;
    };
    this.updatePlacement = () => {
      this.computePlacement();
    };
    this.resetOverlayPosition = () => {
      if (!this.target || !this.options)
        return;
      this.clearOverlayPosition();
      this.host.offsetHeight;
      this.computePlacement();
    };
    this.host = host;
    this.host.addController(this);
  }
  async placeOverlay(target = this.target, options = this.options) {
    this.target = target;
    this.options = options;
    if (!target || !options)
      return;
    const cleanupAncestorResize = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate)(
      options.trigger,
      target,
      this.closeForAncestorUpdate,
      {
        ancestorResize: false,
        elementResize: false,
        layoutShift: false
      }
    );
    const cleanupElementResize = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate)(
      options.trigger,
      target,
      this.updatePlacement,
      {
        ancestorScroll: false
      }
    );
    this.cleanup = () => {
      var _a;
      (_a = this.host.elements) == null ? void 0 : _a.forEach((element) => {
        element.addEventListener(
          "sp-closed",
          () => {
            const placement = this.originalPlacements.get(element);
            if (placement) {
              element.setAttribute("placement", placement);
            }
            this.originalPlacements.delete(element);
          },
          { once: true }
        );
      });
      cleanupAncestorResize();
      cleanupElementResize();
    };
  }
  async computePlacement() {
    var _a, _b;
    const { options, target } = this;
    await (document.fonts ? document.fonts.ready : Promise.resolve());
    const flipMiddleware = !(options.trigger instanceof HTMLElement) ? (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)({
      padding: REQUIRED_DISTANCE_TO_EDGE,
      fallbackPlacements: getFallbackPlacements(options.placement)
    }) : (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)();
    const [mainAxis = 0, crossAxis = 0] = Array.isArray(options == null ? void 0 : options.offset) ? options.offset : [options.offset, 0];
    const tipElement = (_a = this.host.elements.find(
      (el) => el.tipElement
    )) == null ? void 0 : _a.tipElement;
    const middleware = [
      (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)({
        mainAxis,
        crossAxis
      }),
      (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)({ padding: REQUIRED_DISTANCE_TO_EDGE }),
      flipMiddleware,
      (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)({
        padding: REQUIRED_DISTANCE_TO_EDGE,
        apply: ({
          availableWidth,
          availableHeight,
          rects: { floating }
        }) => {
          const maxHeight = Math.max(
            MIN_OVERLAY_HEIGHT,
            Math.floor(availableHeight)
          );
          const actualHeight = floating.height;
          this.initialHeight = !this.isConstrained ? actualHeight : this.initialHeight || actualHeight;
          this.isConstrained = actualHeight < this.initialHeight || maxHeight <= actualHeight;
          const appliedHeight = this.isConstrained ? `${maxHeight}px` : "";
          Object.assign(target.style, {
            maxWidth: `${Math.floor(availableWidth)}px`,
            maxHeight: appliedHeight
          });
        }
      }),
      ...tipElement ? [
        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({
          element: tipElement,
          padding: options.tipPadding || REQUIRED_DISTANCE_TO_EDGE
        })
      ] : []
    ];
    const { x, y, placement, middlewareData } = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(
      options.trigger,
      target,
      {
        placement: options.placement,
        middleware,
        strategy: "fixed"
      }
    );
    Object.assign(target.style, {
      top: "0px",
      left: "0px",
      translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`
    });
    target.setAttribute("actual-placement", placement);
    (_b = this.host.elements) == null ? void 0 : _b.forEach((element) => {
      if (!this.originalPlacements.has(element)) {
        this.originalPlacements.set(
          element,
          element.getAttribute("placement")
        );
      }
      element.setAttribute("placement", placement);
    });
    if (tipElement && middlewareData.arrow) {
      const { x: arrowX, y: arrowY } = middlewareData.arrow;
      Object.assign(tipElement.style, {
        top: placement.startsWith("right") || placement.startsWith("left") ? "0px" : "",
        left: placement.startsWith("bottom") || placement.startsWith("top") ? "0px" : "",
        translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`
      });
    }
  }
  clearOverlayPosition() {
    if (!this.target) {
      return;
    }
    this.target.style.removeProperty("max-height");
    this.target.style.removeProperty("max-width");
    this.initialHeight = void 0;
    this.isConstrained = false;
  }
  hostConnected() {
    document.addEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
  }
  hostUpdated() {
    var _a;
    if (!this.host.open) {
      (_a = this.cleanup) == null ? void 0 : _a.call(this);
      this.cleanup = void 0;
    }
  }
  hostDisconnected() {
    var _a;
    (_a = this.cleanup) == null ? void 0 : _a.call(this);
    this.cleanup = void 0;
    document.removeEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
  }
}
//# sourceMappingURL=PlacementController.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VirtualTrigger: () => (/* binding */ VirtualTrigger)
/* harmony export */ });
/* harmony import */ var _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js");


class VirtualTrigger {
  constructor(x, y) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  updateBoundingClientRect(x, y) {
    this.x = x;
    this.y = y;
    _AbstractOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__.AbstractOverlay.update();
  }
  getBoundingClientRect() {
    return {
      width: 0,
      height: 0,
      top: this.y,
      right: this.x,
      y: this.y,
      x: this.x,
      bottom: this.y,
      left: this.x,
      /* c8 ignore next 3 */
      toJSON() {
        return;
      }
    };
  }
}
//# sourceMappingURL=VirtualTrigger.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/events.dev.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/events.dev.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BeforetoggleClosedEvent: () => (/* binding */ BeforetoggleClosedEvent),
/* harmony export */   BeforetoggleOpenEvent: () => (/* binding */ BeforetoggleOpenEvent),
/* harmony export */   OverlayStateEvent: () => (/* binding */ OverlayStateEvent)
/* harmony export */ });

class BeforetoggleClosedEvent extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "open";
    this.newState = "closed";
  }
}
class BeforetoggleOpenEvent extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "closed";
    this.newState = "open";
  }
}
class OverlayStateEvent extends Event {
  constructor(type, overlay, {
    publish,
    interaction,
    reason
  }) {
    super(type, {
      bubbles: publish,
      composed: publish
    });
    this.overlay = overlay;
    this.detail = {
      interaction,
      reason
    };
  }
}
//# sourceMappingURL=events.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayTimer: () => (/* binding */ OverlayTimer)
/* harmony export */ });

const DEFAULT_WARMUP = 1e3;
const DEFAULT_COOLDOWN = 1e3;
class OverlayTimer {
  constructor(options = {}) {
    this.warmUpDelay = DEFAULT_WARMUP;
    this.coolDownDelay = DEFAULT_COOLDOWN;
    this.isWarm = false;
    this.timeout = 0;
    Object.assign(this, options);
  }
  async openTimer(component) {
    this.cancelCooldownTimer();
    if (!this.component || component !== this.component) {
      if (this.component) {
        this.close(this.component);
        this.cancelCooldownTimer();
      }
      this.component = component;
      if (this.isWarm) {
        return false;
      }
      this.promise = new Promise((resolve) => {
        this.resolve = resolve;
        this.timeout = window.setTimeout(() => {
          if (this.resolve) {
            this.resolve(false);
            this.isWarm = true;
          }
        }, this.warmUpDelay);
      });
      return this.promise;
    } else if (this.promise) {
      return this.promise;
    } else {
      throw new Error("Inconsistent state");
    }
  }
  close(component) {
    if (this.component && this.component === component) {
      this.resetCooldownTimer();
      if (this.timeout > 0) {
        clearTimeout(this.timeout);
        this.timeout = 0;
      }
      if (this.resolve) {
        this.resolve(true);
        delete this.resolve;
      }
      delete this.promise;
      delete this.component;
    }
  }
  resetCooldownTimer() {
    if (this.isWarm) {
      if (this.cooldownTimeout) {
        window.clearTimeout(this.cooldownTimeout);
      }
      this.cooldownTimeout = window.setTimeout(() => {
        this.isWarm = false;
        delete this.cooldownTimeout;
      }, this.coolDownDelay);
    }
  }
  cancelCooldownTimer() {
    if (this.cooldownTimeout) {
      window.clearTimeout(this.cooldownTimeout);
    }
    delete this.cooldownTimeout;
  }
}
//# sourceMappingURL=overlay-timer.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay.css.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay.css.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/index.dev.js");
const o=(0,_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.css)`
    :host{pointer-events:none;--swc-overlay-animation-distance:var(--spectrum-spacing-100);display:contents}:host(:has(>sp-tooltip)){--swc-overlay-animation-distance:var(--spectrum-tooltip-animation-distance)}.dialog{box-sizing:border-box;--sp-overlay-open:true;background:0 0;border:0;max-width:calc(100vw - 16px);height:auto;max-height:calc(100dvh - 16px);margin:0;padding:0;display:flex;position:fixed;inset:0 auto auto 0;overflow:visible;opacity:1!important}.dialog:not([is-visible]){display:none}.dialog:focus{outline:none}dialog:modal{--mod-popover-filter:var(--spectrum-popover-filter)}:host(:not([open])) .dialog{--sp-overlay-open:false}.dialog::backdrop{display:none}.dialog:before{content:"";position:absolute;inset:-999em;pointer-events:auto!important}.dialog:not(.not-immediately-closable):before{display:none}.dialog>div{width:100%}::slotted(*){pointer-events:auto;visibility:visible!important}::slotted(sp-popover){position:static}.dialog:not([actual-placement])[placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog:not([actual-placement])[placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}slot[name=longpress-describedby-descriptor]{display:none}@supports selector(:open){.dialog{opacity:0}.dialog:open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports selector(:popover-open){.dialog{opacity:0}.dialog:popover-open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports (overlay:auto){.dialog{transition:all var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s)),translate 0s,display var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s));transition-behavior:allow-discrete;display:none}.dialog:popover-open,.dialog:modal{display:flex}}@supports (not selector(:open)) and (not selector(:popover-open)){:host:not([open]) .dialog{pointer-events:none}.dialog[actual-placement]{z-index:calc(var(--swc-overlay-z-index-base,1000) + var(--swc-overlay-open-count))}}
`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (o);
//# sourceMappingURL=overlay.css.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/strategies.dev.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/strategies.dev.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strategies: () => (/* binding */ strategies)
/* harmony export */ });
/* harmony import */ var _ClickController_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClickController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/ClickController.dev.js");
/* harmony import */ var _HoverController_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HoverController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/HoverController.dev.js");
/* harmony import */ var _LongpressController_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LongpressController.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/LongpressController.dev.js");




const strategies = {
  click: _ClickController_dev_js__WEBPACK_IMPORTED_MODULE_0__.ClickController,
  longpress: _LongpressController_dev_js__WEBPACK_IMPORTED_MODULE_2__.LongpressController,
  hover: _HoverController_dev_js__WEBPACK_IMPORTED_MODULE_1__.HoverController
};
//# sourceMappingURL=strategies.dev.js.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_spectrum-web-components_overlay_sp-overlay_dev_js-node_modules_spectrum--904e70.spectrum-web-components.js.map